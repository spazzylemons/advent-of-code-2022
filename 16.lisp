(declaim (optimize speed 3))
(declaim (optimize safety 0))

(defun parse-line (line)
  (let ((rate (parse-integer (subseq line (1+ (position #\= line)) (position #\; line))))
        (edges nil)
        (name nil)
        (saved-char nil))
    (dotimes (i (1- (length line)))
      (let ((c (- (char-code (char line (1+ i))) 65)))
        (when (<= 0 c 25)
          (cond (saved-char
                 (let ((n (+ (* 26 saved-char) c)))
                   (if name (push n edges) (setf name n)))
                 (setf saved-char nil))
                (t
                 (setf saved-char c))))))
    (values name edges rate)))

; (defun list-of-keys (hash)
;   (let ((result nil))
;     (maphash #'(lambda (key val) (push key result)))
;     result))

(defun complete-graph-function (edges)
  #'(lambda (valve edge-map)
      (let ((edge-list nil))
        (maphash #'(lambda (key val) (push key edge-list)) edge-map)
        (dolist (u edge-list)
          (dolist (v edge-list)
            (unless (= u v)
              (let ((edge-map-u (gethash u edges))
                    (edge-map-v (gethash v edges))
                    (new-weight (+ (gethash v edge-map) (gethash u edge-map))))
                (when (< new-weight (gethash u edge-map-v 1000))
                  (setf (gethash u edge-map-v) new-weight))
                (when (< new-weight (gethash v edge-map-u 1000))
                  (setf (gethash v edge-map-u) new-weight)))))))))

(defun remove-broken-function (edges rates)
  #'(lambda (valve edge-map)
      (let ((to-remove nil))
        (maphash #'(lambda (key val)
                     (when (= (gethash key rates) 0)
                       (push key to-remove))) edge-map)
        (dolist (key to-remove)
          (remhash key edge-map)))))

(defun process-graph (edges rates)
  (maphash (complete-graph-function edges) edges)
  (maphash (remove-broken-function edges rates) edges))

(defun parse-input (filename)
  (let ((edges (make-hash-table :test #'equal))
        (rates (make-hash-table :test #'equal)))
    (with-open-file (file filename)
      (loop
        (handler-case
          (multiple-value-bind (name neighbors rate) (parse-line (read-line file))
            (format t "~a ~a~%" name neighbors rate)
            (let ((edge-map (make-hash-table :test #'equal)))
              (dolist (neighbor neighbors)
                (setf (gethash neighbor edge-map) 1))
              (setf (gethash name edges) edge-map))
            (setf (gethash name rates) rate))
          (end-of-file () (return)))))
    (process-graph edges rates)
    (values edges rates)))

(defparameter *total-minutes* 30)

(defun calculate-pressure (seq rates)
  (reduce #'+ (mapcar #'(lambda (entry)
                          (* (- *total-minutes* (car entry)) (gethash (cdr entry) rates))) seq)))

(defun part-1 (cache edges rates current minute currently-open)
  (let* ((key (list current minute currently-open))
         (cached (gethash key cache)))
    (or cached (progn
      (let ((best-sequence nil)
            (best-pressure 0))
        (maphash #'(lambda (valve weight)
                     (unless (member valve currently-open)
                       (let ((new-minute (+ minute weight 1))
                             (new-currently-open nil)
                             (seq nil)
                             (pressure nil))
                         (when (< new-minute *total-minutes*)
                           (setf new-currently-open (sort (append currently-open (list valve)) #'<))
                           (setf seq (append (list (cons new-minute valve)) (part-1 cache edges rates valve new-minute new-currently-open)))
                           (setf pressure (calculate-pressure seq rates))
                           (when (> pressure best-pressure)
                             (setf best-pressure pressure)
                             (setf best-sequence seq)))))) (gethash current edges))
        (setf (gethash key cache) best-sequence)
        best-sequence)))))

(defun sort-states (a b)
  (or (< (car a) (car b)) (and (= (car a) (car b)) (< (cdr a) (cdr b)))))

(defun part-2 (cache edges rates states currently-open)
  (let* ((key (list states currently-open))
         (cached (gethash key cache)))
    (or cached (progn
      ; (format t "~a~%" (hash-table-count cache))
      (let ((best-sequence nil)
            (best-pressure 0)
            (state-options (list nil nil)))
        (dotimes (i (length states))
          (let ((minute (car (nth i states)))
                (current (cdr (nth i states))))
            (maphash #'(lambda (valve weight)
                         (unless (member valve currently-open)
                           (let ((new-minute (+ minute weight 1)))
                             (when (< new-minute *total-minutes*)
                               (push (cons new-minute valve) (nth i state-options)))))) (gethash current edges))))
        (dolist (state-1 (car state-options))
          (dolist (state-2 (cadr state-options))
            (let ((new-states (sort (list state-1 state-2) #'sort-states))
                  (new-currently-open (copy-list currently-open))
                  (seq nil)
                  (pressure nil))
              (when (= (cdar new-states) (cdadr new-states))
                (setf (cdr new-states) nil))
              (dolist (new-state new-states)
                (push (cdr new-state) new-currently-open))
              (setf new-currently-open (sort new-currently-open #'<))
              (setf new-currently-open (delete-duplicates new-currently-open))
              (setf seq (append new-states (part-2 cache edges rates new-states new-currently-open)))
              (setf pressure (calculate-pressure seq rates))
              (when (> pressure best-pressure)
                (setf best-pressure pressure)
                (setf best-sequence seq)))))
        (setf (gethash key cache) best-sequence)
        best-sequence)))))

(multiple-value-bind (edges rates) (parse-input "input")
  (format t "~a ~a~%" edges rates)
  (let ((cache (make-hash-table :test #'equal)))
    (format t "part 1: ~a~%" (calculate-pressure (part-1 cache edges rates 0 0 nil) rates)))
  (setf *total-minutes* (- *total-minutes* 4))
  (let ((cache (make-hash-table :test #'equal)))
    (format t "part 2: ~a~%" (calculate-pressure (part-2 cache edges rates (list (cons 0 0) (cons 0 0)) nil) rates))))
