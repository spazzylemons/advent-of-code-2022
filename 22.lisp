(defparameter *deltas* (make-array 4 :initial-contents (list (cons 1 0) (cons 0 1) (cons -1 0) (cons 0 -1))))

(defparameter *face-size* 50)

(defparameter *which-next* (make-hash-table :test #'equal))
(setf (gethash (cons 1 0) *which-next*) 'r)
(setf (gethash (cons 0 1) *which-next*) 'd)
(setf (gethash (cons -1 0) *which-next*) 'l)
(setf (gethash (cons 0 -1) *which-next*) 'u)

(defun convert-direction (dir)
  (cond ((equal dir "L") 'l)
        ((equal dir "R") 'r)
        (t (parse-integer dir))))

(defun parse-input (filename)
  (let ((tiles (make-hash-table :test #'equal))
        (y 0)
        (start-pos nil)
        (face-positions nil))
    (with-open-file (file filename)
      (loop as line = (read-line file)
            while (> (length line) 0)
            do (dotimes (x (length line))
                 (let ((pos (cons x y))
                       (c (char line x)))
                   (unless (equal c #\space)
                     (when (and (= y 0) (not start-pos))
                       (setf start-pos (cons x y)))
                     (when (and (= (mod y *face-size*) (mod x *face-size*) 0))
                       (push (cons (/ x *face-size*) (/ y *face-size*)) face-positions))
                     (setf (gethash pos tiles) c))))
               (incf y))
      (let ((line (read-line file))
            (start-index 0)
            (directions nil))
        (dotimes (index (length line))
          (when (or (equal (char line index) #\R)
                    (equal (char line index) #\L))
            (push (convert-direction (subseq line start-index index)) directions)
            (push (convert-direction (subseq line index (1+ index))) directions)
            (setf start-index (1+ index))))
        (push (convert-direction (subseq line start-index)) directions)
        (setf directions (nreverse directions))
        (values tiles start-pos directions face-positions)))))

(defun cubemap-assignment (tiles sidemap x y mapping)
  (when (not (gethash (gethash 'f sidemap) mapping))
    (setf (gethash (gethash 'f sidemap) mapping) (cons x y))
    (when (gethash (cons (* (1- x) *face-size*) (* y *face-size*)) tiles)
      (let ((new-sidemap (make-hash-table :test #'equal)))
        (setf (gethash 'f new-sidemap) (gethash 'l sidemap))
        (setf (gethash 'l new-sidemap) (gethash 'b sidemap))
        (setf (gethash 'b new-sidemap) (gethash 'r sidemap))
        (setf (gethash 'r new-sidemap) (gethash 'f sidemap))
        (setf (gethash 'u new-sidemap) (gethash 'u sidemap))
        (setf (gethash 'd new-sidemap) (gethash 'd sidemap))
        (cubemap-assignment tiles new-sidemap (1- x) y mapping)))
    (when (gethash (cons (* (1+ x) *face-size*) (* y *face-size*)) tiles)
      (let ((new-sidemap (make-hash-table :test #'equal)))
        (setf (gethash 'f new-sidemap) (gethash 'r sidemap))
        (setf (gethash 'r new-sidemap) (gethash 'b sidemap))
        (setf (gethash 'b new-sidemap) (gethash 'l sidemap))
        (setf (gethash 'l new-sidemap) (gethash 'f sidemap))
        (setf (gethash 'u new-sidemap) (gethash 'u sidemap))
        (setf (gethash 'd new-sidemap) (gethash 'd sidemap))
        (cubemap-assignment tiles new-sidemap (1+ x) y mapping)))
    (when (gethash (cons (* x *face-size*) (* (1- y) *face-size*)) tiles)
      (let ((new-sidemap (make-hash-table :test #'equal)))
        (setf (gethash 'f new-sidemap) (gethash 'u sidemap))
        (setf (gethash 'u new-sidemap) (gethash 'b sidemap))
        (setf (gethash 'b new-sidemap) (gethash 'd sidemap))
        (setf (gethash 'd new-sidemap) (gethash 'f sidemap))
        (setf (gethash 'l new-sidemap) (gethash 'l sidemap))
        (setf (gethash 'r new-sidemap) (gethash 'r sidemap))
        (cubemap-assignment tiles new-sidemap x (1- y) mapping)))
    (when (gethash (cons (* x *face-size*) (* (1+ y) *face-size*)) tiles)
      (let ((new-sidemap (make-hash-table :test #'equal)))
        (setf (gethash 'f new-sidemap) (gethash 'd sidemap))
        (setf (gethash 'd new-sidemap) (gethash 'b sidemap))
        (setf (gethash 'b new-sidemap) (gethash 'u sidemap))
        (setf (gethash 'u new-sidemap) (gethash 'f sidemap))
        (setf (gethash 'l new-sidemap) (gethash 'l sidemap))
        (setf (gethash 'r new-sidemap) (gethash 'r sidemap))
        (cubemap-assignment tiles new-sidemap x (1+ y) mapping)))))

(defun add-cons (a b)
  (cons (+ (car a) (car b)) (+ (cdr a) (cdr b))))

(defun next-tile-pos (tiles pos delta)
  (let ((new-pos (add-cons pos delta)))
    (if (gethash new-pos tiles)
      new-pos
      (let ((reverse-delta (cons (- (car delta)) (- (cdr delta)))))
        (loop
          (setf new-pos (add-cons pos reverse-delta))
          (unless (gethash new-pos tiles)
            (return pos))
          (setf pos new-pos))))))

(defun part-1 (tiles pos facing directions)
  (if (car directions)
    (let ((dir (car directions)))
      (if (integerp dir)
        (let ((delta (aref *deltas* facing)))
          (loop
            (when (= dir 0) (return))
            (let ((new-pos (next-tile-pos tiles pos delta)))
              (when (equal (gethash new-pos tiles) #\#)
                (return))
              (decf dir)
              (setf pos new-pos))))
        (if (equal dir 'l)
          (setf facing (mod (1- facing) 4))
          (setf facing (mod (1+ facing) 4))))
      (part-1 tiles pos facing (cdr directions)))
    (+ (* 1000 (1+ (cdr pos))) (* 4 (1+ (car pos))) facing)))

(defun make-cube-assignment (tiles start-pos)
  (let ((sidemap (make-hash-table :test #'equal))
        (mapping (make-hash-table :test #'equal)))
    (setf (gethash 'f sidemap) 'f)
    (setf (gethash 'r sidemap) 'r)
    (setf (gethash 'b sidemap) 'b)
    (setf (gethash 'l sidemap) 'l)
    (setf (gethash 'u sidemap) 'u)
    (setf (gethash 'd sidemap) 'd)
    (cubemap-assignment tiles sidemap (car start-pos) (cdr start-pos) mapping)
    mapping))

(defun next-tile-pos-and-rotation (tiles pos delta dir face-mappings)
  (let ((new-pos (add-cons pos delta))
        (top-left (cons (floor (/ (car pos) *face-size*))
                        (floor (/ (cdr pos) *face-size*)))))
    (if (and (= (car top-left) (floor (/ (car new-pos) *face-size*)))
             (= (cdr top-left) (floor (/ (cdr new-pos) *face-size*))))
      (progn
        (values new-pos 0))
      (let* ((face-mapping (gethash top-left face-mappings))
             (which-next (gethash (gethash delta *which-next*) face-mapping))
             (dest-face-mapping (gethash which-next face-mappings))
             (rotation-change 0))
        (cond ((equal (gethash 'l dest-face-mapping) top-left)
               (setf rotation-change 0))
              ((equal (gethash 'u dest-face-mapping) top-left)
               (setf rotation-change 1))
              ((equal (gethash 'r dest-face-mapping) top-left)
               (setf rotation-change 2))
              ((equal (gethash 'd dest-face-mapping) top-left)
               (setf rotation-change 3)))
        (setf rotation-change (mod (- rotation-change dir) 4))
        ; move to face-local coords
        (setf (car new-pos) (mod (car new-pos) *face-size*))
        (setf (cdr new-pos) (mod (cdr new-pos) *face-size*))
        ; rotate based on rotation change
        (dotimes (_ rotation-change)
          (let ((new-x (- (1- *face-size*) (cdr new-pos)))
                (new-y (car new-pos)))
            (setf new-pos (cons new-x new-y))))
        ; restore to global coordinates
        (setf (car new-pos) (+ (car new-pos) (* (car which-next) *face-size*)))
        (setf (cdr new-pos) (+ (cdr new-pos) (* (cdr which-next) *face-size*)))
        (values new-pos rotation-change)))))

(defun part-2-recursive (tiles pos facing directions face-mappings)
  (if (car directions)
    (let ((dir (car directions)))
      (if (integerp dir)
        (let ((delta (aref *deltas* facing)))
          (loop
            (when (= dir 0) (return))
            (multiple-value-bind (new-pos rotation-change) (next-tile-pos-and-rotation tiles pos delta facing face-mappings)
              (when (equal (gethash new-pos tiles) #\#)
                (return))
              (decf dir)
              (setf pos new-pos)
              (setf facing (mod (+ facing rotation-change) 4))
              (setf delta (aref *deltas* facing)))))
        (if (equal dir 'l)
          (setf facing (mod (1- facing) 4))
          (setf facing (mod (1+ facing) 4))))
      (part-2-recursive tiles pos facing (cdr directions) face-mappings))
    (+ (* 1000 (1+ (cdr pos))) (* 4 (1+ (car pos))) facing)))

(defun part-2 (tiles start-pos directions face-positions)
  (let ((face-mappings (make-hash-table :test #'equal)))
    (dolist (pos face-positions)
      (setf (gethash pos face-mappings) (make-cube-assignment tiles pos)))
    (part-2-recursive tiles start-pos 0 directions face-mappings)))

(multiple-value-bind (tiles start-pos directions face-positions) (parse-input "input")
  (format t "part 1: ~a~%" (part-1 tiles start-pos 0 directions))
  (format t "part 2: ~a~%" (part-2 tiles start-pos directions face-positions)))
