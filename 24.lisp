(defparameter *max-steps* 1000)

(defun parse-input (filename)
  (let ((blizzards nil)
        (y 0)
        (width 0))
    (with-open-file (file filename)
      (setf width (- (length (read-line file)) 2))
      (loop
        (let ((line (read-line file)))
          (when (equal (char line 1) #\#) (return))
          (dotimes (x (- (length line) 2))
            (let ((c (char line (1+ x))))
              (unless (equal c #\.)
                (push (list c y x) blizzards))))
          (incf y))))
    (values blizzards width y)))

(defun blizzard-delta (c)
  (case c
    (#\> (cons 0 1))
    (#\v (cons 1 0))
    (#\< (cons 0 -1))
    (#\^ (cons -1 0))))

(defun blizzards-at-time (blizzards width height minute)
  (let ((result (make-array (list (+ height 2) (+ width 2)) :initial-element nil)))
    (dotimes (y (+ height 2))
      (setf (aref result y 0) t)
      (setf (aref result y (1+ width)) t))
    (dotimes (x (+ width 2))
      (setf (aref result 0 x) t)
      (setf (aref result (1+ height) x) t))
    (setf (aref result 0 1) nil)
    (setf (aref result (1+ height) width) nil)
    (dolist (blizzard blizzards)
      (let* ((delta (blizzard-delta (car blizzard)))
             (y (1+ (mod (+ (cadr blizzard) (* (car delta) minute)) height)))
             (x (1+ (mod (+ (caddr blizzard) (* (cdr delta) minute)) width))))
        (setf (aref result y x) t)))
    result))

(defun part-1 (cache minute y x states goal-x goal-y)
  (let* ((cache-key (list minute y x))
         (cached (gethash cache-key cache)))
    (or cached (let* ((state (aref states (mod minute (array-dimension states 0))))
                      (height (array-dimension state 0))
                      (width (array-dimension state 1))
                      (best-result *max-steps*))
                 (if (and (= x goal-x) (= y goal-y))
                   (setf best-result (1- minute))
                   (let ((can-go-r (and (< (1+ x) width) (not (aref state y (1+ x)))))
                         (can-go-l (and (>= (1- x) 0) (not (aref state y (1- x)))))
                         (can-go-d (and (< (1+ y) height) (not (aref state (1+ y) x))))
                         (can-go-u (and (>= (1- y) 0) (not (aref state (1- y) x))))
                         (can-stay (not (aref state y x))))
                     (cond ((> minute *max-steps*) nil)
                           (t
                            (when can-go-d
                              (setf best-result (min best-result (part-1 cache (1+ minute) (1+ y) x states goal-x goal-y))))
                            (when can-go-r
                              (setf best-result (min best-result (part-1 cache (1+ minute) y (1+ x) states goal-x goal-y))))
                            (when can-go-u
                              (setf best-result (min best-result (part-1 cache (1+ minute) (1- y) x states goal-x goal-y))))
                            (when can-go-l
                              (setf best-result (min best-result (part-1 cache (1+ minute) y (1- x) states goal-x goal-y))))
                            (when can-stay
                              (setf best-result (min best-result (part-1 cache (1+ minute) y x states goal-x goal-y))))))))
                 (setf (gethash cache-key cache) best-result)
                 best-result))))

(multiple-value-bind (blizzards width height) (parse-input "input")
  (let ((states (make-array (lcm width height)))
        (trip-a 0)
        (trip-b 0)
        (trip-c 0))
    (dotimes (i (array-dimension states 0))
      (setf (aref states i) (blizzards-at-time blizzards width height i)))
    (let ((cache (make-hash-table :test #'equal)))
      (setf trip-a (part-1 cache 1 0 1 states width (1+ height))))
    (let ((cache (make-hash-table :test #'equal)))
      (setf trip-b (part-1 cache (1+ trip-a) (1+ height) width states 1 0)))
    (let ((cache (make-hash-table :test #'equal)))
      (setf trip-c (part-1 cache (1+ trip-b) 0 1 states width (1+ height))))
    (format t "part 1: ~a~%" trip-a)
    (format t "part 2: ~a~%" trip-c)))
