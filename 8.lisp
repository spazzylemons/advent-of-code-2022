(load "util.lisp")

(defun find-blocking (grid test y x dy dx)
  (let ((ny (+ y dy))
        (nx (+ x dx))
        (size (array-dimension grid 0)))
    ; out of range? return nil
    ; tree is blocked? return 1
    ; otherwise, recurse
    (cond ((or (< nx 0) (< ny 0) (>= nx size) (>= ny size))
           nil)
          ((>= (aref grid ny nx) test)
           1)
          (t
           (let ((result (find-blocking grid test ny nx dy dx)))
             (if result (1+ result) nil))))))

(let* ((lines (read-lines "input"))
       (size (length lines))
       (grid (make-array (list size size)))
       (part-1-result (* 4 (1- size)))
       (part-2-result 0))
  (let ((y 0))
    (dolist (line lines)
      (dotimes (x (length line))
        (setf (aref grid y x) (parse-integer (subseq line x (1+ x)))))
      (incf y)))
  (loop for y from 1 below (1- size)
        do (loop for x from 1 below (1- size)
                 do (let* ((current (aref grid y x))
                           (dist-up (find-blocking grid current y x -1 0))
                           (dist-left (find-blocking grid current y x 0 -1))
                           (dist-right (find-blocking grid current y x 0 1))
                           (dist-down (find-blocking grid current y x 1 0)))
                      (unless (and dist-up dist-left dist-right dist-down)
                        (incf part-1-result))
                      (let ((score (* (or dist-up y)
                                      (or dist-left x)
                                      (or dist-right (- size x 1))
                                      (or dist-down (- size y 1)))))
                        (setf part-2-result (max part-2-result score))))))
  (format t "~a~%" part-1-result)
  (format t "~a~%" part-2-result))
